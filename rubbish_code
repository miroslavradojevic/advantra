    private int score(
							 float locX, float locY,
							 FloatProcessor inip1,
							 FloatProcessor backgr1,
							 FloatProcessor margin1,
							 ArrayList<ArrayList<Float>> peakIdxsAtLoc, //[2][nr. conv. points]
							 float scale_A, float scale_B) 				// 2 rings specific
	{
		logWriter.println(IJ.d2s(locX, 0) + "," + IJ.d2s(locY, 0) + " -> ");

		/*******************/

		// precheck
		int nrPointsA = peakIdxsAtLoc.get(0).size();
		if (nrPointsA < 3) {
			logWriter.println("ring A : "+peakIdxsAtLoc.get(0).size()+" peaks => NO");
			return 0;
		}

		int nrPointsB = peakIdxsAtLoc.get(1).size();
		if (nrPointsB < 3) {
			logWriter.println("ring B : "+peakIdxsAtLoc.get(1).size()+" peaks => NO");
			return 0;
		}

		// before mapping (need to have them as lists to match)
		ArrayList<ArrayList<Float>> peakAngsAtLoc = new ArrayList<ArrayList<Float>>(2);

		ArrayList<Float> peakAngA 	= new ArrayList<Float>(nrPointsA);
		for (int ii=0; ii<nrPointsA; ii++)
			peakAngA.add(ii, peakIdxsAtLoc.get(0).get(ii) * Profiler.getResolDeg(scale_A));

		peakAngsAtLoc.add(peakAngA);

		ArrayList<Float> peakAngB   = new ArrayList<Float>(nrPointsB);
		for (int ii=0; ii<nrPointsB; ii++)
			peakAngB.add(ii, peakIdxsAtLoc.get(1).get(ii) * Profiler.getResolDeg(scale_B));

		peakAngsAtLoc.add(peakAngB);

//		log += "ring angles: ";
//		for (int i=0; i<peakAngsAtLoc.size(); i++) {
//			log += "ring "+i+" : ";
//			for (int j=0; j<peakAngsAtLoc.get(i).size(); j++) {
//				log += peakAngsAtLoc.get(i).get(j)+" ";
//			}
//		}
//		log += "\n";

		// map[k][0] is index in peakAngsAtLoc.get(0), map[k][1] is index in peakAngsAtLoc.get(1)
		int[][] map = Tools.hungarianMappingAnglesDeg(peakAngsAtLoc.get(0), peakAngsAtLoc.get(1));

		logWriter.println(map.length + " matches"); // map.length >= 3

		// remap points in arrays
		float[][][] p = new float[2][map.length][2]; // [ring idx][cluster idx][xy]

		for (int k=0; k<map.length; k++) { // k loops clusters
				// ring A   take map[k][0] element
				p[0][k][0] =
				(float) (locX + D * scale_A * Math.cos(peakAngsAtLoc.get(0).get(map[k][0]) * Deg2Rad));
				p[0][k][1] =
				(float) (locY - D * scale_A * Math.sin(peakAngsAtLoc.get(0).get(map[k][0]) * Deg2Rad));
				// ring B   take map[k][1] element
				p[1][k][0] =
				(float) (locX + D * scale_B * Math.cos(peakAngsAtLoc.get(1).get(map[k][1]) * Deg2Rad));
				p[1][k][1] =
				(float) (locY - D * scale_B * Math.sin(peakAngsAtLoc.get(1).get(map[k][1]) * Deg2Rad));
		}

		// check each cluster of the 2 ring combination for directionality ( mapping does not mean they're aligned)
		ArrayList<Integer> idxDirectedClusters = new ArrayList<Integer>(map.length);
		for (int k=0; k<map.length; k++) {  // 3 or 4 clusters

			logWriter.println("mapping # "+locX+" , "+locY+" , "+p[0][k][0]+" , "+p[0][k][1]+" , "+p[1][k][0]+" , "+p[1][k][1]);
			float cosAngle = Tools.angularDeviation(locX, locY, p[0][k][0], p[0][k][1], p[1][k][0], p[1][k][1]);
			logWriter.println("mapping # "+k+" cos(ang) = "+cosAngle+" : "+peakAngsAtLoc.get(0).get(map[k][0])+" \t "+peakAngsAtLoc.get(1).get(map[k][1]));

			if (cosAngle>MIN_COS_ANG
						&&
						isForeground(p[0][k], inip1, backgr1)
						&&
						isForeground(p[1][k], inip1, backgr1)
					) {
				idxDirectedClusters.add(k); // contains mapping index k
			}
		}

		logWriter.println("found "+idxDirectedClusters.size()+" aligned foreground clusters out of matched "+map.length+" ... ");

		if (idxDirectedClusters.size()<3) {
			return 0; // idxDirectedClusters.size() how many matched & directed
		}

		// check directions for each ring
		float[][] directionsRad = new float[2][idxDirectedClusters.size()];  // at least 2x3, 2x4
		for (int d=0; d<idxDirectedClusters.size(); d++) {
				// ring A
				int k = idxDirectedClusters.get(d); // map[k][0] is index in A, map[k][1] is index in B
				directionsRad[0][d] = peakAngsAtLoc.get(0).get(map[k][0]) * Deg2Rad;
				directionsRad[1][d] = peakAngsAtLoc.get(1).get(map[k][1]) * Deg2Rad;
		}
		// don't allow any inter-angle to be more than 180 deg.
		Arrays.sort(directionsRad[0]);
		Arrays.sort(directionsRad[1]);

		logWriter.println("checked directions in [deg] : ");
		for (int i=0; i< directionsRad.length; i++) {
			logWriter.println("ring "+i+" : ");
			for (int j=0; j< directionsRad[0].length; j++) {
				logWriter.print( (directionsRad[i][j]*Rad2Deg)+" ");
			}
			logWriter.println();
		}

		// checking angles

/*		if (!sortedDirectionsAnglesAreLessThanPI(directionsRad[0])) {
			logWriter.println("ring A had two directions with illegal angle => NO");
			return 0;
		}
		if (!sortedDirectionsAnglesAreLessThanPI(directionsRad[1])) {
			logWriter.println("ring B had two directions with illegal angle => NO");
			return 0;
		}*/

		// check each ring profile
		boolean chk;
		float r_A = (float) (D*scale_A);
		chk = profileOK(locX, locY, r_A, directionsRad[0], inip1, backgr1, margin1);
//		if (!chk) {
//			logWriter.println("profile A was illegal");
//			return 0;
//		}
		float r_B = (float) (D*scale_B);
		chk = profileOK(locX, locY, r_B, directionsRad[1], inip1, backgr1, margin1);
//		if (!chk) {
//			logWriter.println("profile B was illegal");
//			return 0;
//		}

		logWriter.println(" YES! \n");

		/*******************/

		return 255;

    }




	private boolean isForeground(float[] loc, FloatProcessor inip1, FloatProcessor back1, FloatProcessor marg1)
	{
		return Interpolator.interpolateAt(loc[0], loc[1], inip1) > Interpolator.interpolateAt(loc[0], loc[1], back1) + Interpolator.interpolateAt(loc[0], loc[1], marg1);
	}

	private boolean sortedDirectionsAnglesAreLessThanPI(float[] angsRad)
	{

		if (angsRad[0]-angsRad[angsRad.length-1]+(2*Math.PI)>Math.PI) {
			return false;
		}

		for (int i=1; i<angsRad.length; i++) {
			if (angsRad[i]-angsRad[i-1]>Math.PI) {
				return false;
			}
		}

		return true;

	}

    private boolean isForeground(float[] loc, FloatProcessor inip1, FloatProcessor back1)
    {
        return Interpolator.interpolateAt(loc[0], loc[1], inip1) > Interpolator.interpolateAt(loc[0], loc[1], back1);
    }


    //    public void mouseClicked(MouseEvent e)
    //    {
    //
    //		// on mouse click extract locations, plot profile, intensities along profile and overlay points
    //        currOvl.clear();
    //        currOvl = detectionOverlay.duplicate();
    //
    //        int offscreenX = canvas.offScreenX(e.getX());
    //        int offscreenY = canvas.offScreenY(e.getY());
    //
    //        IJ.log(""+offscreenX+", "+offscreenY+" \n");
    //
    //        //float cI = Interpolator.interpolateAt(offscreenX, offscreenY, (FloatProcessor) imp.getProcessor());
    //        //float cB = Interpolator.interpolateAt(offscreenX, offscreenY, (FloatProcessor) Masker.backgr);
    //        PointRoi pt = new PointRoi(offscreenX+.5, offscreenY+.5);
    //        currOvl.add(pt);
    //
    //        // define ring A
    //        double rd_A = D*scale;
    //        OvalRoi ring_A = new OvalRoi(offscreenX-rd_A+.5, offscreenY-rd_A+.5, 2*rd_A, 2*rd_A);
    //        currOvl.add(ring_A);
    //
    //        profile_A = Profiler.extractProfile(D, scale, offscreenX, offscreenY, (FloatProcessor) imp.getProcessor());
    //        peakIdx_A = Analyzer.extractPeakIdxs(profile_A, startMS, finishMS); // MS returns values range [0, length)
    //
    //        ArrayList<Float> A_Ang  = new ArrayList<Float>(4); // store those that were selected as ok
    //        ArrayList<Float> A_x    = new ArrayList<Float>(4);
    //        ArrayList<Float> A_y    = new ArrayList<Float>(4);
    //
    //		peakAng_A   = null;
    //        if (peakIdx_A!=null) {
    //            float[] peakX_A, peakY_A, peakI_A, peakB_A;
    //            peakAng_A = new float[peakIdx_A.length];
    //                    peakX_A = new float[peakIdx_A.length];
    //                            peakY_A = new float[peakIdx_A.length];
    //                                    peakI_A = new float[peakIdx_A.length];
    //                                            peakB_A = new float[peakIdx_A.length];
    //
    //            for (int i=0; i<peakIdx_A.length; i++) {
    //                peakAng_A[i] = peakIdx_A[i] * Profiler.getResolDeg(scale) * Deg2Rad;
    //                peakX_A[i] = (float) (offscreenX + rd_A * Math.cos( peakAng_A[i] ));
    //                peakY_A[i] = (float) (offscreenY - rd_A * Math.sin( peakAng_A[i] ));
    //                peakI_A[i] = Interpolator.interpolateAt(peakX_A[i], peakY_A[i], (FloatProcessor) imp.getProcessor());
    //                peakB_A[i] = Interpolator.interpolateAt(peakX_A[i], peakY_A[i], Masker.backgr);
    //
    ////					PointRoi pt = new PointRoi(peakX_A[i]+.5, peakY_A[i]+.5);
    ////                  pt.setStrokeColor(getColor(i));
    ////                  currOvl.add(pt);
    //
    //				A_Ang.add(peakIdx_A[i] * Profiler.getResolDeg(scale)); // because hungarian matching method will take angle differences in degrees
    //                A_x.add(peakX_A[i]);
    //                A_y.add(peakY_A[i]);
    //
    //            }
    //        }
    //
    //        /*
    //        visualizations
    //         */
    //
    //		Plot chartP_A, chartI_A;
    //        float[] profile_A_MinMax = Tools.getMinMax(profile_A);
    //
    //        if (pwI_A == null) {
    //            ang_A   = new float[profile_A.length];
    //            i_A     = new float[profile_A.length];
    //            iTh_A   = new float[profile_A.length];
    //        }
    //
    //        for (int i = 1; i <= ang_A.length; i++) {
    //            ang_A[i - 1] = (i-1)*Profiler.getResolDeg(scale);
    //            float pX = (float) (offscreenX + rd_A * Math.cos( ang_A[i - 1] * Deg2Rad ));
    //            float pY = (float) (offscreenY - rd_A * Math.sin( ang_A[i - 1] * Deg2Rad ));
    //            i_A[i-1]    = Interpolator.interpolateAt(pX, pY, (FloatProcessor) imp.getProcessor());
    //            iTh_A[i-1]  = Interpolator.interpolateAt(pX, pY, Masker.backgr);// + Interpolator.interpolateAt(pX, pY, Masker.margin);
    //        }
    //
    //        chartP_A = new Plot("", "", "", ang_A, profile_A);
    //        chartP_A.setSize(500, 250);
    //
    ///*        if (peakIdx_A!=null) {
    //            float[] dummyX = new float[peakIdx_A.length];
    //            for (int i=0; i<dummyX.length; i++) dummyX[i] = peakIdx_A[i] * Profiler.getResolDeg(scale_A);
    //            float[] dummyY = new float[peakIdx_A.length];
    //            for (int i=0; i<dummyY.length; i++) dummyY[i] = (float) Tools.interp1Darray(peakIdx_A[i], profile_A);// peakIdx_A[i] * Profiler.getResolDeg(scale_A);
    //            chartP_A.addPoints(dummyX, dummyY, PlotWindow.BOX);
    //        }*/
    //
    //
    //        chartP_A.addPoints(ang_A, profile_A, PlotWindow.CIRCLE);
    //        chartP_A.draw();  chartP_A.setColor(Color.RED);
    //        // draw peak detections
    //        if (peakAng_A!=null)
    //            for (int i = 0; i < peakIdx_A.length; i++) {
    //                chartP_A.drawLine(peakAng_A[i] * Rad2Deg, profile_A_MinMax[0], peakAng_A[i] * Rad2Deg, Tools.interp1Darray(peakIdx_A[i], profile_A));
    //            }
    //
    //        chartI_A = new Plot("", "", "", ang_A, i_A);
    //        chartI_A.setSize(500, 250);
    //		chartI_A.addPoints(ang_A, i_A, PlotWindow.CIRCLE);
    //        chartI_A.draw(); chartI_A.setColor(Color.BLUE);
    //        chartI_A.addPoints(ang_A, iTh_A, PlotWindow.LINE);
    //        chartI_A.draw();  chartI_A.setColor(Color.RED);
    //        // draw peak detections
    //        if (peakAng_A!=null)
    //            for (int i = 0; i < peakIdx_A.length; i++)
    //                chartI_A.drawLine(peakAng_A[i] * Rad2Deg, Tools.interp1Darray(peakIdx_A[i], iTh_A), peakAng_A[i] * Rad2Deg, Tools.interp1Darray(peakIdx_A[i], i_A));
    //
    //        if (pwP_A == null) pwP_A = chartP_A.show();
    //        pwP_A.drawPlot(chartP_A);
    //        pwP_A.setTitle("RING A: profile, x = " + offscreenX + ", y = " + offscreenY);
    //
    //        if (pwI_A == null) pwI_A = chartI_A.show();
    //        pwI_A.drawPlot(chartI_A);
    //        pwI_A.setTitle("RING A: intenst, x = " + offscreenX + ", y = " + offscreenY);
    //
    //        /*
    //        **************************
    //         */
    //
    //        // define ring B, similarly as A
    ////        scale_B = scale_A + 1;
    //        double rd_B = D*scale;
    //        OvalRoi ringB = new OvalRoi(offscreenX-rd_B+.5, offscreenY-rd_B+.5, 2*rd_B, 2*rd_B);
    //        currOvl.add(ringB);
    //
    //        profile_B = Profiler.extractProfile(D, scale, offscreenX, offscreenY, (FloatProcessor) imp.getProcessor());
    //        peakIdx_B = Analyzer.extractPeakIdxs(profile_B, startMS, finishMS); // MS values range [0, length)
    //
    //        ArrayList<Float> B_Ang  = new ArrayList<Float>(4); // store those that were selected as ok
    //        ArrayList<Float> B_x    = new ArrayList<Float>(4);
    //        ArrayList<Float> B_y    = new ArrayList<Float>(4);
    //
    //        peakAng_B   = null;
    //        if (peakIdx_B!=null) {
    //            float[] peakX_B, peakY_B, peakI_B, peakB_B;
    //            peakAng_B = new float[peakIdx_B.length];
    //            peakX_B = new float[peakIdx_B.length];
    //            peakY_B = new float[peakIdx_B.length];
    //            peakI_B = new float[peakIdx_B.length];
    //            peakB_B = new float[peakIdx_B.length];
    //
    //            for (int i=0; i<peakIdx_B.length; i++) {
    //                peakAng_B[i] = peakIdx_B[i] * Profiler.getResolDeg(scale) * Deg2Rad;
    //                peakX_B[i] = (float) (offscreenX + rd_B * Math.cos( peakAng_B[i] ));
    //                peakY_B[i] = (float) (offscreenY - rd_B * Math.sin( peakAng_B[i] ));
    //                peakI_B[i] = Interpolator.interpolateAt(peakX_B[i], peakY_B[i], (FloatProcessor) imp.getProcessor());
    //                peakB_B[i] = Interpolator.interpolateAt(peakX_B[i], peakY_B[i], Masker.backgr);
    //
    ////				PointRoi pt = new PointRoi(peakX_B[i]+.5, peakY_B[i]+.5);
    ////              pt.setStrokeColor(getColor(i));
    ////              currOvl.add(pt);
    //
    //				B_Ang.add(peakIdx_B[i] * Profiler.getResolDeg(scale)); // because hungarian matching method will take angle differences in degrees
    //                B_x.add(peakX_B[i]);
    //                B_y.add(peakY_B[i]);
    //
    //            }
    //        }
    //
    //        /*
    //        **************************
    //         */
    //
    //        int[][] map = Tools.hungarianMappingAnglesDeg(A_Ang, B_Ang); // map(A ring index, B ring index)
    //
    //        // after mapping
    //        float[] angDiv = new float[map.length];
    //
    //        for (int k=0; k<map.length; k++) {
    //
    //            // point in A : A_x.get(map[k][0], A_y.get(map[k][0])
    //            float ax = A_x.get(map[k][0]);
    //            float ay = A_y.get(map[k][0]);
    //			// add it
    //            pt = new PointRoi(ax+.5, ay+.5);
    //            pt.setStrokeColor(getColor(k));
    //            currOvl.add(pt);
    //
    //            // point in B : B_x.get(map[k][1]), B_y.get(map[k][1])
    //            float bx = B_x.get(map[k][1]);
    //            float by = B_y.get(map[k][1]);
    //			// add it
    //            pt = new PointRoi(bx+.5, by+.5);
    //            pt.setStrokeColor(getColor(k));
    //            currOvl.add(pt);
    //
    //			IJ.log("mapping # "+offscreenX+" , "+offscreenY+" , "+ax+" , "+ay+" , "+bx+" , "+by+"\n");
    //
    //            angDiv[k] = Tools.angularDeviation(offscreenX, offscreenY, ax, ay, bx, by);
    //
    //            IJ.log("mapping # "+k+" cos(ang) = "+angDiv[k]+" : "+A_Ang.get(map[k][0])+" \t "+B_Ang.get(map[k][1]));
    //
    //			if (angDiv[k]>MIN_COS_ANG) {
    //
    //				PolygonRoi pr = new PolygonRoi(
    //													  new float[]{offscreenX+.5f, ax+.5f, bx+.5f},
    //													  new float[]{offscreenY+.5f, ay+.5f, by+.5f},
    //													  3,
    //													  PolygonRoi.FREELINE
    //													  );
    //				currOvl.add(pr);
    //
    //			}
    //
    //        }
    //
    //		//System.out.println("\nCLUSTER ANG DIVS "+Arrays.toString(angDiv));
    //		//IJ.log("\nCLUSTER ANG DIVS "+Arrays.toString(angDiv));
    //
    //        /*
    //        **************************
    //         */
    //
    //        canvas.setOverlay(currOvl);
    //
    //
    //    }


	private boolean profileOK(
										float posx,
										float posy,
										float posr,
										float[] dirAngRadSorted,
										FloatProcessor inip1,
										FloatProcessor backgr1,
										FloatProcessor margin1)
	{
		float DF = 0.001f;
		float oStep = (float) (2*Math.PI)/100f;
		int totalPeaks = dirAngRadSorted.length;

		boolean up, down; // check if it went below th. between peaks
		float currX, currY, currI, currB, currM;

		// directionAnglesRadSorted[0]
		up = false;
		down = true;
		for (float aa=dirAngRadSorted[0]; aa>=dirAngRadSorted[dirAngRadSorted.length-1]-2*Math.PI+DF; aa-=oStep) {
			currX = (float) (posx + posr * Math.cos(aa));
			currY = (float) (posy - posr * Math.sin(aa));
			currI = Interpolator.interpolateAt(currX, currY, inip1);
			currB = Interpolator.interpolateAt(currX, currY, backgr1);
			currM = Interpolator.interpolateAt(currX, currY, margin1);
			up = up || (currI>currB);  //+currM
			down = up && (currI<currB); //Masker.HYSTERESIS     +currM
			if (down) break;
		}
		if (!down) {
			logWriter.println("between "+(dirAngRadSorted[0]*Rad2Deg)+" and "+(dirAngRadSorted[dirAngRadSorted.length-1]*Rad2Deg));
			return false; // don't go further
		}

		// the rest
		for (int peakIdx=1; peakIdx<totalPeaks; peakIdx++) {
			up = false;
			down = true;
			for (float aa=dirAngRadSorted[peakIdx]; aa>=dirAngRadSorted[peakIdx-1]+DF; aa-=oStep) {
				currX = (float) (posx + posr * Math.cos(aa));
				currY = (float) (posy - posr * Math.sin(aa));
				currI = Interpolator.interpolateAt(currX, currY, inip1);
				currB = Interpolator.interpolateAt(currX, currY, backgr1);
				currM = Interpolator.interpolateAt(currX, currY, margin1);
				up = up || (currI>currB);     //+currM
				down = up && (currI<currB); // Masker.HYSTERESIS  +currM
				if (down) break;
			}
			if (!down) {
				logWriter.println("between "+(dirAngRadSorted[peakIdx]*Rad2Deg)+" and "+(dirAngRadSorted[peakIdx-1]*Rad2Deg));
				return false; // don't go further
			}
		}

		return true;

	}